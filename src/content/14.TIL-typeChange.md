---
title: '자바스크립트 타입 변환'
author: [woodaehyun]
tags: [lang, Javascript, til]
image: null
date: '2023-01-29T00:00:00.000Z'
draft: false
excerpt: '모던 자바스크립트 책을 3회독 하면서 나의 생각과 주요 개념 정의를 다시 짚어 보려한다. 오늘은 타입 변환에 대한 개념을 다시 공부하고 정의를 명확하게 하고 생각을 정리하기 위한 시간을 보냈다.'
---

블로그를 작성하기에 앞서 내가 다시 이 책을 공부하는 이유에 대해서 먼저 설명해 보자면 지금까지는 안다고 생각한것들을 설명하지 못한다는 사실을 발견했기 때문이다. **변수란 뭔가요?** 라는 질문에 나는 꽤 많은 고민을 했고 너무 당연히 알고 있다고 생각한 개념을 다른 누군가에게 설명하지 못했다. 그래서 정확하게 개념들을 다시 짚기 위해서 읽기 시작했고 이미 기본적인 대부분의 내용들을 알고 있었기 때문에 `개념에 대한 명확한 정의`를 내리고 내 생각을 정리해 나가고자 한다. 그 세 번째 타자가 바로 `타입 변환`이다! 자 드가자~🎉 책의 동작 원리들을 정리하는 것이 아닌 주요 개념 명확하게 하고 그에 대한 나만의 생각을 정리할 예정이다.

---

## 타입 변환

우리가 코드를 작성하면서 이미 잘 활용하고 있는 사람도 있을 것이고 예상하지 못한 데이터 타입의 변경으로 인해 그 원인을 찾고자 고생한 경험을 한 사람도 있을 것이다. 그 이유는 자바스크립트 엔진에 의해서 `타입이 강제로 변환`되기 때문이다. 그럼 우선 정확한 개념 정의를 해보자!

> **암묵적 타입 변환, 타입 강제 변환이 뭐죠?**

**_개발자의 의도와 상관없이 표현식을 평가하는 도중에 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되는 것이다._**

이에 반대되는 개념은 명시적 타입 변환이다. 말 그대로 개발자의 의도에 따라 다른 타입으로 변환하는 것을 말한다.
여기서 한 가지 알아두면 좋은 것은 `암묵적 타입 변환`은 기존 변수 값을 재할당하여 변경하는 것이 아니라 **자바스크립트 엔진에 의해 표현식을 에러 없이 평가하기 위해 피연산자의 값을 암묵적으로 변환해 새로운 타입의 값을 만들어서 한 번만 사용하고 버리는 방식으로 동작한다** 는 점이다.

```javascript
const number = 0;
console.log(!!number); // false
console.log(number); // 0
```

내가 주로 **조건식**에 많이 사용하는 `falsy`로 평가되는 값을 예로 들어봤다. 숫자 값 0은 falsy한 값으로 불리언 값을 피연산자로 갖는 연산자를 사용하는 경우 불리언 타입의 값 `false`로 암묵적 타입 변환되어 새로운 타입의 값을 만들어 단 한 번만 사용하고 버리게 된다. 이 부분은 자바스크립트의 똑똑한 면모를 보여주는게 아닌가 싶다.

**사용된 연산자**는 각 연산의 목적을 가지고 있고, 그 목적에 맞는 값을 반환받기를 개발자가 원한다고 생각하여 암묵적으로 타입을 변경하여 반환해 주니 말이다. 그리고 또 이러한 타입변환을 잘 이해하고 사용한다면, 개발자에게 보다 간결한 코드를 작성할 수 있도록 만들어 줄 수도 있기 때문에 단순히 명확하지 않다는 이유로 부정하는 것은 옳지 못한 태도인 것 같다. 하지만 정확하게 이해하지 못한다면 엄청난 혼란이 초래될 것은 분명하다.

여기서 한 가지 신기한 점은 자바스크립트 엔진에 의해서 이러한 동작이 가능한데 자바스크립트 엔진도 결국 누군가에 의해서 만들어진 것일텐데 어떻게 이러한 타입 변환이 가능한지 궁금증이 생겼다. 그 궁금증에 대해서 간단하게 추론해 보자면 앞서 말했듯이 **모든 연산자는 목적이 존재하고 해당 목적에 맞는 값을 반환하기 위해 존재한다.** 예를들어 `*`는 `좌항의 숫자 값`과 `우항의 숫 값`을 곱하기 위해서 존재하는 연산자이고, 두 수를 곱하여 `하나의 숫자 값`을 반환하기 위해 존재한다. 그렇다면 자바스크립트 엔진은 `*`연산자를 인식하고 **좌항과 우항의 데이터 타입을 비교하여 숫자 데이터가 들어 있지 않은 경우** 강제적으로 숫자 타입의 값으로 변경을 할 것이고 암묵적 타입 변환을 하는 기준들을 이미 설정해 놓은 방식으로 동작하는 것이라고 생각할 수 있을 것 같다.

이렇게 생각한 이유는 예를 들어 `String.prototype.indexOf 메서드`를 활용하여 특정 `문자`가 몇 번째 `index`에 존재하는지 확인한다고 했을 때 내부 동작으로는 `반복문`을 통해 문자열의 각 문자를 반복하면서 찾고자 하는 문자와 일치하는 첫 번째 `index`번호를 찾아 반환하고 반복문을 종료하게 동작하는 것처럼 생각보다 동작원리는 복잡하지 않은 경우가 많으니 말이다. 어디까지나 나만의 생각이다.ㅎㅎ🤓

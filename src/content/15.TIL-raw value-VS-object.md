---
title: '자바스크립트 원시 값 vs 객체'
author: [woodaehyun]
tags: [lang, Javascript, til]
image: null
date: '2023-01-30T01:00:00.000Z'
draft: false
excerpt: '모던 자바스크립트 책을 3회독 하면서 나의 생각과 주요 개념 정의를 다시 짚어 보려한다. 원시 값과 객체의 비교에 대해 다시 공부하고 정의를 명확하게 하고 생각을 정리하기 위한 시간을 보냈다.'
---

블로그를 작성하기에 앞서 내가 다시 이 책을 공부하는 이유에 대해서 먼저 설명해 보자면 지금까지는 안다고 생각한것들을 설명하지 못한다는 사실을 발견했기 때문이다. **변수란 뭔가요?** 라는 질문에 나는 꽤 많은 고민을 했고 너무 당연히 알고 있다고 생각한 개념을 다른 누군가에게 설명하지 못했다. 그래서 정확하게 개념들을 다시 짚기 위해서 읽기 시작했고 이미 기본적인 대부분의 내용들을 알고 있었기 때문에 `개념에 대한 명확한 정의`를 내리고 내 생각을 정리해 나가고자 한다. 그 다섯 번째 타자가 바로 `원시 값과 객체의 비교`이다! 자 드가자~🎉 책의 동작 원리들을 정리하는 것이 아닌 주요 개념 명확하게 하고 그에 대한 나만의 생각을 정리할 예정이다.

---

## 원시 값과 객체의 비교

앞서 데이터 타입에서 살펴본 것들에 이어서 오늘은 데이터 타입내에서의 분류인 원시 타입의 값과 객체에 대해서 비교하는 시간을 보냈다. 우선 정확한 개념 정의를 해보자.

> **원시 타입의 값이 뭐죠?**

**_원시 타입의 값이란 변경 불가능한 값을 말한다._**

> **객체 타입의 값이 뭐죠?**

**_객체 타입의 값이란 변경 가능한 값을 말한다.(뭐 물론 배열, 객체 등을 말할 수 있지만 여기선 둘의 비교하기 위해 정의했다.)_**

우선 원시 타입의 값이 무엇인지 생각해보면, 정의한대로 변경이 불가능한 값이다. 여기서 변경이 불가능하다는 의미의 `주체`를 잘 알아둘 필요가 있다. 여기서 말하는 변경 불가능 하다는 것은 `변수`가 변경이 불가능하다는 것이 아니라 `값`이 변경이 불가능하다는 의미임을 명확하게 알아야 한다. 여기서 변경 불가능 하다는 의미를 정확하게 이해하기 어려울 수 있는데, 다음 예시를 한 번 살펴보면 확실하게 감이 올 것이다.

```javascript
var score = 80;
score = 90;
```

1. **_var 키워드로 선언한 변수는 호이스팅과 함께 undefined로 초기화 될 것이고 다음과 같이 메모리에 저장될 것이다._**<br/>
   | 식별자 | 메모리주소 | 메모리 |
   | :----: | :--------: | :-------: |
   | - | 0x1234xa | - |
   | score | 0x1554xb | undefined |
   | - | 0x1664xc | - |

2. **_그 다음 런타임에 자바스크립트 엔진에 의해서 메모리 공간을 확보한 후 숫자 리터럴 80이 평가되어 숫자 값 80을 다음과 같이 저장 할 것이다._**<br/>
   | 식별자 | 메모리주소 | 메모리 |
   | :----: | :--------: | :-------: |
   | - | 0x1234xa | - |
   | - | 0x1554xb | undefined |
   | score | 0x1664xc | 80 |
   | - | 0x1224xd | - |

3. **_그 다음 코드에서 숫자 리터럴 90이 평가되어 숫자 값 90을 다음과 같이 재할당하여 저장 할 것이다._**<br/>
   | 식별자 | 메모리주소 | 메모리 |
   | :----: | :--------: | :-------: |
   | - | 0x1234xa | - |
   | - | 0x1554xb | undefined |
   | - | 0x1664xc | 80 |
   | score | 0x1224xd | 90 |

엄밀하게 위와 같이 동작하진 않겠지만, 대략적인 큰 그림은 동일하다. 위의 테이블을 다시 확인해 보면 score가 가리키는 메모리 공간은 계속 달라지고 해당 score에 할당되어 있던 값들은 제거되지 않고 그대로 남아 있는것을 확인할 수 있다. 만약 원시 값이 변경이 가능한 값이 었다면 score가 가리키는 메모리주소는 동일한 주소를 계속해서 가리킬 것이고, 메모리에 들어있는 원시 값만 변경되게 될 것이기 때문이다. 이러한 이유로 `원시 타입의 값`은 `변경 불가능한 값`이라고 불리는 것이다.

원시 값은 어떤 일이 있어도 불변하기 때문에 변경으로부터 자유롭고 이는 데이터의 신뢰성을 보장한다고 했다. 나는 개인적으로 하지만 원시 타입 값이 갖게 되는 `불변성`특징이 주는 장점에 대해서는 공감하기 힘들다. **왜냐하면 재할당이 이뤄지는 방법으로 데이터 자체는 변경될 수 없지만 변수의 데이터는 변경될 수 있고, 개발자의 입장에서는 변수의 값이 달라지는 점이 가장 큰 위협이 아닐까라는 생각이 들기 때문이다.** 또 이러한 문제도 const 키워드를 통해 예기치 못한 재할당도 방어할 수 있기 때문에 단순히 변경이 불가능한 값의 특징인 불변성에 대한 공감을 하기 힘들다.(뭐 물론 아직 생각의 깊이가 깊지 못해서 일지는 모르지만..🥲) 또 자바스크립트 코드를 작성하면서 불편했던 점은 `문자열`데이터를 다룰때 인 것 같다. 특정 문자만을 변경하는 로직을 구현해야하는 경우도 많이 존재하는데 변경 불가능한 값이기 때문에 별도의 raplace메서드와 같은 치환해주는 메서드들을 활용해서 `문자열`데이터를 다뤄야 한다. 분명 내부 로직을 본다면 변경 불가능한 값인 문자열의 특정 부분을 변경하기 위해 **반복문을 돌면서 문자들을 하나씩 새로운 변수에 담고 바꾸고자 하는 부분만 변경하여 문자들을 연결하고 이를 반환해주는 방식**으로 동작할 것으로 예상되는데 굳이 변경이 불가능할 필요가 있는 것일까? 라는 생각이 들었다.

그리고 메모리 공간의 활용도 마찬가지라고 생각한다. 위의 예시처럼 변수가 가리키는 메모리 주소가 바뀌고 이전 값들은 그대로 메모리 공간에 남아있고 새로운 메모리 공간에 값을 저장하게 된다. 뭐 물론 `자바스크립트`는 `매니지드 언어`로 `가비지 컬렉터`에 의해서 더 이상 사용하지 않는 값들은 자동으로 정리가 되지만 어찌됐든 이 또한 메모리 공간 활용에 비효율적인 부분이 있는게 아닌가 하는 생각이 들었다.

또 다른 원시 값의 큰 특징은 `값에 의한 전달`이다. 값에 의한 전달이라는 것은 **원시 값을 가지고 있는 변수를 다른 변수에 할당한 경우 원시 값을 가지고 있는 변수의 원시 값 자체가 복사되어 새로운 값으로 할당하는 변수에 할당 된다는 점이다.** 즉, 특정 값이 들어 있는 메모리 셀을 동시에 공유하는 것이 아니라, 값이 복사되어 새로운 메모리 공간에 저장되어 할당받는 변수는 새로운 메모리 공간을 가리키게 된다.(파이썬의 경우 동작 방식이 약간 다르지만 결론은 동일하다.)

```javascript
var score = 80;
copy = score;
score = 90;
console.log(copy); // 80
console.log(score); // 90
```

**_각 변수가 별개의 메모리 주소를 가리키고 각각 별개의 값을 갖는다.(복사되어 전달하기 때문)_**<br/>
| 식별자 | 메모리주소 | 메모리 |
| :----: | :--------: | :-------: |
| score | 0x1234xa | 80 |
| - | 0x1554xb | - |
| copy | 0x1664xc | 80 |

이러한 이유로 score 변수의 값으리 변경해도 copy 변수의 값에는 어떠한 영향도 미치지 않는다. 이 부분은 원시 값의 장점인 것 같다. 이 다음으로 이야기하겠지만 비교하겠지만 객체의 경우에는 `참조 값`이 전달되기 때문에 예상치 못한 개발자의 실수를 유발할 수도 있다. 하지만 원시 타입의 값 같은 경우에는 완전히 복사하여 새로운 값을 전달하기 때문에 이러한 부분에서 안전할 수 있다고 생각한다. (**역시 모든 일장일단이 있는 듯 싶다!**)

---

이미 언급했지만 객체의 경우에는 `참조 값`이 전달되게 된다. 참조 전달이란 말 그대로 객체가 저장되어 있는 메모리 주소를 복사하여 전달한다는 것이다. 원시 값의 경우에는 변수가 가리키는 메모리 공간에 `원시 값`이 그대로 들어 있다. 예를 들어 숫자의 경우에는 숫자 값 80이 그대로 들어있다는 의미이다. 하지만 **객체의 경우에는 객체가 식별자가 가리키는 메로리 공간이 아닌 다른 메모리 공간에 저장이 되고 그 저장이 되어 있는 메모리 공간의 주소가 객체를 할당한 변수가 가리키는 메로리 공간에 저장되게 된다.** 쉽게 표로 만들어 보면, 다음과 같다.

```javascript
var object = [1, 2, 3];
copy = object;
object[0] = 100;
console.log(copy); // [100,2,3]
console.log(score); // [100,2,3]
```

| 식별자 | 메모리주소 |  메모리  |
| :----: | :--------: | :------: |
| object |  0x1234xa  | 0x1664xc |
|   -    |  0x1554xb  |    -     |
|   -    |  0x1664xc  | [1,2,3]  |

그럼 이 객체가 할당되어 있는 변수를 다른 변수에 할당하면 어떻게 될까? 동작원리는 원시 값과 동일하다. 값을 복사하여 전달하게 되는데 이 값이 `메모리 주소`일 뿐인 것이다. 하지만 각 변수에서 객체를 변경한다면 **원시 값과는 완전 다른 결과가 나오게 된다.** 즉, 여러 개의 식별자가 하나의 객체를 공유할 수 있다는 말이다.

이 두 차이점이 객체와 원시 값의 가장 큰 차이점이라고 볼 수 있다. 그렇다면 객체는 왜 `참조 값`을 전달하고 원시 값은 `값`을 전달할까? 그 이유는 비용측면에서 고려된 설계라고 볼 수 있다. 객체는 원시 값처럼 크기가 일정하지도 않고 프로퍼티 값이 객체일 수도 있어서 복사해서 생성하게 되면 비용이 많이 들게 된다. 즉, 메모리측면에서도 부정적이고 성능도 나빠지기 때문이다.

**_이런 이유라면 충분히 납득이 가능한 이유가 아닐까라는 생각이 든다.👍_** 우리 모두가 슈퍼컴퓨터를 사용하여 메모리 공간이 흘러 넘치고 연산 속도도 빨라지는 것이 아니라면 충분히 현실적으로 최선의 방법이지 않을까 생각이 든다. 이 부분은 정말 많은 오류를 발생시킬 수 있는 부분이겠지만, 이 부분 만큼은 개발자가 자바스크립트의 동작 원리를 정확하게 이해하고 활용하는게 현실적으로 최선의 방법이라는 생각이 든다. 만약 정말 복사가 필요한 경우에는 `얕은 복사`나 `깊은 복사`를 통해 충분히 해결할 수 있기 때문이다!

그치만 에러는 언제나 화가 난다🤯
